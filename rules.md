AI Operational Context & Guiding Principles1. Project OverviewCore Mission: Your primary objective is to build a native iOS child locator application according to the tasks defined in ai_project_plan.json.Single Source of Truth: The ai_project_plan.json file is your only task list. All work must correspond to a specific taskId from this file. Do not invent new tasks or deviate from the specified deliverables.Technology Stack: The project must exclusively use the following technologies:Language: SwiftUI Framework: SwiftUIBackend: Google Firebase (Authentication, Firestore, Cloud Functions)Mapping: Apple MapKit2. Task Execution WorkflowWhen I give you a command like "Start task IOS-02", you must follow this exact procedure:Locate Task: Find the corresponding task object in ai_project_plan.json using the taskId.Verify Dependencies: Check the dependencies array for that task. Confirm with me that the deliverables from the prerequisite tasks have been completed and are available to you.Request Context: You are responsible for managing the project's state. You must always request the most recent and complete source code from the previous task before starting your work. Do not assume you have it.Execute: Perform the work as described in the task's description.Deliver: Provide the output precisely as specified in the deliverables array. For source code, this means providing the entire, complete, and runnable Xcode project source files. Do not provide snippets, diffs, or patches. Every code deliverable must be a full replacement for the previous version.3. File and Code ManagementStateless Operation: Assume you are a new instance of the AI starting each task. You do not retain memory of files from previous tasks. This is why you must always request the latest code.Complete Files Only: Every file you generate must be complete and self-contained. For example, when delivering the firestore.rules, provide the entire file, not just the changed rules. When delivering a SwiftUI View, provide the entire .swift file.Project Structure: Maintain a conventional and clean Xcode project structure. All new code should be logically organized. For example, Firebase-related logic should be encapsulated in a dedicated service or repository class, not mixed directly into SwiftUI views.Data Models: All custom data structures that will be written to or read from Firestore (e.g., User, Location) must be defined as Swift structs conforming to the Codable protocol.4. Code Quality and Best PracticesModern SwiftUI: Use modern SwiftUI patterns and property wrappers (@State, @StateObject, @EnvironmentObject, @ObservedObject). Avoid UIKit unless absolutely necessary and explicitly requested.Clarity and Comments: Write clean, readable code. Add comments to explain complex logic, background processes, or the purpose of specific functions.Error Handling: Implement robust error handling. Do not use ! to force-unwrap optionals. Use guard let or if let for safe unwrapping. For operations that can fail (like network requests), use Swift's Result type or do-catch blocks.User Privacy: When requesting permissions (especially Location), you must generate the code to include a clear and user-friendly justification string for the Info.plist file, explaining exactly why the permission is needed.5. Interaction ProtocolAsk for Clarification: If any part of a task description is ambiguous or seems to conflict with a previous instruction, you must ask for clarification before proceeding. Do not make assumptions.Be Explicit: When you complete a task, explicitly state the taskId you have finished and list the deliverables you are providing, matching the list in ai_project_plan.json.